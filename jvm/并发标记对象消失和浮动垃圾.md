并发标记产生的问题

可达性分析算法的前提：**该算法的全过程都需要基于一个能保障一致性的快照中才能够分析，这意味着必须全程冻结用户线程的运行**

##### 1.假设冻结用户线程来执行垃圾回收

###### 第一步：是需要找到根节点

由于GC Roots是远远少于整个java堆中的全部对象的，而且在OopMap此类优化技巧的加持下，它带来的停顿时间是非常短暂且相对固定的，**可以理解为不会随着堆里面的对象的增加而增加**，大概就是下面这个图的意思：

![image-20210810135738989](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810135739.png)



###### 第二步：**从GC Roots往下继续遍历对象图，进行"标记"过程**

一步的停顿时间必然是**随着java堆中的对象增加而增加的**

![image-20210810140026507](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810140030.png)

这个逻辑不复杂：堆约大，存储的对象越多，对象图结构越复杂，要标记更多对象，所以产生的停顿时间也自然就长了

经过上面的分析，**我们知道了，根节点的枚举阶段是不太耗时的，也不会随着java堆里面存储的对象增加而增加耗时。而"标记"过程的耗时是会随着java堆里面存储的对象增加而增加的。**

"标记"阶段是所有使用可达性分析算法的垃圾回收器都有的阶段。因此我们可以知道，如果能够**削减"标记"过程这部分的停顿时间，那么收益将是可观的。**

要消减这一部分的停顿时间。那就是**让垃圾回收器和用户线程同时运行**，并发工作。也就是我们说的并发标记的阶段。



##### 2.为什么遍历对象图的时候必须在一个能保障一致性的快照中

###### （1）什么是"三色标记"

《深入理解Java虚拟机(第三版)》中是这样描述的：

**白色：表示对象尚未被垃圾回收器访问过**。显然，在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。

**黑色：表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过**。黑色的对象代表已经扫描过，它是安全存活的，如果有其它的对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。

**灰色：表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过**。

![image-20210810142440341](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810142440.png)

灰色对象是黑色对象与白色对象之间的中间态。当标记过程结束后，只会有黑色和白色的对象，而**白色的对象就是需要被回收的对象。**

###### (2) 在可达性分析的扫描过程中：

① 如果**只有垃圾回收线程在工作**，那肯定不会有任何问题

② 在**垃圾回收器和用户线程同时运行**时

垃圾回收器在对象图上面标记颜色，而同时用户线程在修改引用关系，引用关系修改了，那么对象图就变化了，这样就有可能出现两种后果：

**一种是把原本消亡的对象错误的标记为存活，这不是好事，但是其实是可以容忍的，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以** ,如下图：4,7,8,10,11就是浮动垃圾

<img src="https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810143353.awebp"/>



**一种是把原本存活的对象错误的标记为已消亡，这就是非常严重的后果了，一个程序还需要使用的对象被回收了，那程序肯定会因此发生错误。**



##### (3) 并发标记中对象消失过程

###### ① 正常并发标记流程



<img src="https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810143805.webp"/>

**标记结果如下：**

![image-20210810143848596](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810143848.png)



② 对象消失情况一

如果用户线程在标记的时候，修改了引用关系，就会出现下面的情况：

<img src="https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810143952.webp"/>



扫描结果如下：

对象9在失去对象6的引用后，被标记成白色，之后又被对象5引用，但此时对象9已经被标记为白色，会被垃圾回收掉

![image-20210810144038807](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810144038.png)



###### ③ 对象消失的情况二



<img src="https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810144401.webp"/>

上面演示的是用户线程切断引用后重新被黑色对象引用的对象就是原来引用链的一部分。

对象7和对象10本来就是原引用链（根节点->5->6->7->8->11->10）的一部分。修改后的引用链变成了（根节点->5->6->7->10）。

扫描后结果:

![image-20210810144511077](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810144511.png)

由于黑色对象不会重新扫描，这将导致扫描结束后对象10和对象11都会回收了。他们都是被修改之前的原来的引用链的一部分。

经过分析：**并发标记除了会产生浮动垃圾，还会出现"对象消失"的问题。**



#### 怎么解决"对象消失"问题呢

Wilson，他在1994年在理论上证明了，**当且仅当以下两个条件同时满足时**，会产生"对象消失"的问题

原来应该是黑色的对象被误标为了白色：

**条件一：赋值器插入了一条或者多条从黑色对象到白色对象的新引用。**

**条件二：赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。**

![image-20210810145013080](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810145013.png)

由于两个条件之间是当且仅当的关系。所以，我们要解决并发标记时对象消失的问题，只需要破坏两个条件中的任意一个就行。

于是产生了两种解决方案：**增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。**

**CMS是基于增量更新来做并发标记的，G1则采用的是原始快照的方式。**

#### 什么是增量更新呢？

增量更新要破坏的是第一个条件（赋值器插入了一条或者多条从黑色对象到白色对象的新引用）

当**黑色对象插入新的指向白色对象的引用关系时**，就将**这个新插入的引用记录下来**，等**并发扫描结束**之后，再**将这些记录过的引用关系中的黑色对象为根，重新扫描一次。**

可以简化的理解为：黑色对象一旦插入了指向白色对象的引用之后，它就变回了灰色对象。

<img src="https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810145351.webp"/>

这样对象9又被扫描成为了黑色。也就不会被回收，所以不会出现对象消失的情况



#### 什么是原始快照呢？（保存引用删除前的快照记录）

原始快照要破坏的是第二个条件（赋值器删除了全部从灰色对象到该白色对象的直接或间接引用）

当**灰色对象要删除指向白色对象的引用关系时**，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的**引用关系中的灰色对象为根**，重新扫描一次。

**注：保存对象6到对象9前的引用删除前记录，之后从对象6再扫描一次，由于是删除前的快照，所以6到9的引用还在，**

**所以对象9不会被删除**

<img src="https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810145432.webp"/>





**注：需要注意的是，上面的介绍中无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。**



1.这里的写屏障和我们常说的为了解决并发乱序执行问题的"内存屏障"不是一码事，需要区分开来。

2.写屏障可以看作虚拟机层面对"引用类型字段赋值"这个动作的AOP切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫做写前屏障(Pre-Write Barrier)，在赋值后的则叫作写后屏障(Post-Write Barrier)。

所以，经过简单的推导我们可以知道：

**增量更新用的是写后屏障(Post-Write Barrier)，记录了所有新增的引用关系。**

**原始快照用的是写前屏障(Pre-Write Barrier)，将所有即将被删除的引用关系的旧引用记录下来。**



#### 并发标记的时候用户线程分配了新对象，G1是怎么处理的呢？



