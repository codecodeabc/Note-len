https://juejin.cn/post/6844904078451933197

#### G1收集器内存结构

虽然还是保留的有新生代和老年代的概念，但是新生代和老年代之前再也不是区域上的隔离了。**它将整个 Java 堆划分为多个大小相等的独立区域，叫做 Region 。而新生代和老年代就是由一个个 Region 动态组成的区域，它们可以是不连续的区间。**

**每一个 Region 都可以根据需要，扮演新生代的 Eden 空间，Survivor 空间，或者老年代空间。除此之外它还有一类特殊的区域叫做 Humongous，专门用来存储大对象。**



##### CMS收集器内存分布

不论是年轻代、老年代都是逻辑上连续的空间（但是不要求物理上的连续）

![image-20210810151217714](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810151217.png)



G1收集器内存分布

G1的堆内存被划分为多个大小相等的 Region ，但是 Region 的总个数在 2048 个左右，默认是 2048 。对于一个 Region 来说，是逻辑连续的一段空间，其大小的取值范围是 1MB 到 32MB 之间

![image-20210810153253811](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810153253.png)

上面的E、S和没有写字母的蓝色方块（可以理解为old）没啥说的。

但是可以看到H是以往的垃圾收集器中没有的概念，它代表 Humongous，这**表示这些 Region 存储的是巨型对象（humongous object，H-obj），当新建对象大小超过 Region 大小一半时，直接在新的一个或多个连续 Region 中分配，并标记为H。**



注意到我上面说的几个数据了吗，2048个左右，1MB到32MB，这些数据是哪里来的呢，我说你就信了吗？

很多文章聊到G1的时候都只是说**堆内存被划分为多个大小相等的 Region** ， Region 大小的取值范围为 1MB 到 32MB ，但是并没有提到 2048 这回事，我来给你寻根问祖一下：

![image-20210810154019389](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810154019.png)

我找到的第一个数据来源于上面的这篇论文，即文末的资料4：

> The goal is to have around 2048 regions for the total heap.

这篇论文的作者是Monica Beckwith，你可以去搜一下，她（是的，我没打错，是个妹子）担任过Oracle G1 垃圾收集器性能团队 Leader，权威吧。

第二个数据来源当然是源码了，更权威吧：

> http://hg.openjdk.java.net/jdk/jdk/file/fa2f93f99dbc/src/hotspot/share/gc/g1/heapRegionBounds.hpp



![image-20210810154053462](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/20210810154053.png)



#### G1的工作步骤

##### 1.从执行步骤分为四个步骤

**初始标记(Initial Marking)**：这阶段仅仅只是标记GC Roots能直接关联到的对象并修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段需要停顿线程，但是耗时很短。

而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

**并发标记(Concurrent Marking)**：从GC Roots开始对堆的对象进行可达性分析，递归扫描整个堆里的对象图，找出存活的对象，这阶段耗时较长，但是可以与用户程序并发执行。

当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。

**最终标记(Final Marking)**：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。

**筛选回收(Live Data Counting and Evacuation)**：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划。

可以**自由选择任意多个 Region 构成回收集**，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。

这里的**操作涉及存活对象的移动，是必须暂停用户线程**，由多条收集器线程并行完成的。



##### 2. 整个算法的角度，可以切分为两大部分

**Gobal Concurrent Marking：全局并发标记。**

**Evacuation Pauses：该阶段是负责把一部分Region里的活对象拷贝到空Region里面去，然后回收原本的Region空间。**

###### 

https://juejin.cn/post/6844904078451933197