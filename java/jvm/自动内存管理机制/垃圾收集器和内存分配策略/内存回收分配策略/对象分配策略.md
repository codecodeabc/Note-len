
#### 对象分配策略 -  http://svip.iocoder.cn/Java/VirtualMachine/Interview/#对象分配规则是什么？


#### 分配规则总结

##### 1.对象优先分配在 Eden 区

```text
如果 Eden 区无法分配，那么尝试把活着的对象放到 Survivor0 中去（Minor GC）

如果 Survivor0 可以放入，那么放入之后清除 Eden 区。
如果 Survivor0 不可以放入，那么尝试把 Eden 和 Survivor0 的存活对象放到 Survivor1 中。
如果 Survivor1 可以放入，那么放入 Survivor1 之后清除 Eden 和 Survivor0 ，之后再把 Survivor1 中的对象复制到 Survivor0 中，保持 Survivor1 一直为空。
如果 Survivor1 不可以放入，那么直接把它们放入到老年代中，并清除 Eden 和 Survivor0 ，这个过程也称为分配担保。
ps：清除 Eden、Survivor 区，就是 Minor GC 。

总结来说，分配的顺序是：新生代（Eden => Survivor0 => Survivor1）=> 老年代
```

##### 2.大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）

```text
这样做的目的是，避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
```

##### 3.长期存活的对象进入老年代

```text
虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1 ，知道达到阀值对象进入老年区
```
##### 4.动态判断对象的年龄

```text
为了更好的适用不同程序的内存情况，虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代。

如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
```
##### 5.空间分配担保

```text
每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC ，
如果小于检查 HandlePromotionFailure 设置，如果 true 则只进行 Monitor GC ，如果 false 则进行 Full GC 。
```


#### 新生代设计 eden 和 survivor 的原因

https://blog.csdn.net/qq_27093465/article/details/79802884
