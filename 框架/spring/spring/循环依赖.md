https://mp.weixin.qq.com/s/pQaX2-BqFsO3pzPELWIDfQ

##### 单例循环依赖

1.通过构造器注入： spring 无法解决此种循环依赖

2.Set方法注入： spring 通过三个缓存来提前暴露bean解决循环依赖

```
1.从容器中获取serviceA
2.容器尝试从3个缓存中找serviceA，找不到
3.准备创建serviceA
4.调用serviceA的构造器创建serviceA，得到serviceA实例，此时serviceA还未填充属性，未进行其他任何初始化的操作
5.将早期的serviceA暴露出去：即将其丢到第3级缓存singletonFactories中
6.serviceA准备填充属性，发现需要注入serviceB，然后向容器获取serviceB
7.容器尝试从3个缓存中找serviceB，找不到
8.准备创建serviceB
9.调用serviceB的构造器创建serviceB，得到serviceB实例，此时serviceB还未填充属性，未进行其他任何初始化的操作
10.将早期的serviceB暴露出去：即将其丢到第3级缓存singletonFactories中
11.serviceB准备填充属性，发现需要注入serviceA，然后向容器获取serviceA
12.容器尝试从3个缓存中找serviceA，发现此时serviceA位于第3级缓存中，经过处理之后，serviceA会从第3级缓存中移除，然后会存到第2级缓存中，然后将其返回给serviceB，此时serviceA通过serviceB中的setServiceA方法被注入到serviceB中
13.serviceB继续执行后续的一些操作，最后完成创建工作，然后会调用addSingleton方法，将自己丢到第1级缓存中，并将自己从第2和第3级缓存中移除
14.serviceB将自己返回给serviceA
15.serviceA通过setServiceB方法将serviceB注入进去
16.serviceB继续执行后续的一些操作，最后完成创建工作,然后会调用addSingleton方法，将自己丢到第1级缓存中，并将自己从第2和第3级缓存中移除
```



##### 非单例循环依赖

**只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中**

非单例两种情况

以2个bean相互依赖为例：serviceA和serviceB

### 情况1

#### 条件

serviceA：多例

serviceB：多例

#### 结果

此时不管是任何方式都是无法解决循环依赖的问题，最终都会报错，因为每次去获取依赖的bean都会重新创建。

### 情况2

#### 条件

serviceA：单例

serviceB：多例

#### 结果

若使用构造器的方式相互注入，是无法完成注入操作的，会报错。

若采用set方式注入，所有bean都还未创建的情况下，若去容器中获取serviceB，会报错，为什么？我们来看一下过程：

```
1.从容器中获取serviceB
2.serviceB由于是多例的，所以缓存中肯定是没有的
3.检查serviceB是在正在创建的bean名称列表中，没有
4.准备创建serviceB
5.将serviceB放入正在创建的bean名称列表中
6.实例化serviceB（由于serviceB是多例的，所以不会提前暴露，必须是单例的才会暴露）
7.准备填充serviceB属性，发现需要注入serviceA
8.从容器中查找serviceA
9.尝试从3级缓存中找serviceA，找不到
10.准备创建serviceA
11.将serviceA放入正在创建的bean名称列表中
12.实例化serviceA
13.由于serviceA是单例的，将早期serviceA暴露出去，丢到第3级缓存中
14.准备填充serviceA的属性，发现需要注入serviceB
15.从容器中获取serviceB
16.先从缓存中找serviceB，找不到
17.检查serviceB是在正在创建的bean名称列表中,发现已经存在了，抛出循环依赖的异常
```

这个有演示的源码，位置：

com.javacode2018.lesson003.demo2.CircleDependentTest#test2