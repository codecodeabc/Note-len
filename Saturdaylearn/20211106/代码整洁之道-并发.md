#### 一、为什么要并发

![image-20211106135557856](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061355947.png)

#### 二、并发多线程问题

![image-20211106135645514](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061356586.png)



#### 三、并发防御原则

##### 1.单一权责原则

**即：并发代码要和生产或业务代码分离开来，单独作为一个功能点处理，要将并发功能拆分到足够小，可以理解成单独的一个函数或小功能来处理**

![image-20211106135819348](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061358403.png)

##### 2.推论：限制数据作用域

##### ![image-20211106140042434](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061400524.png)

![image-20211106140053655](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061400706.png)



##### 3.推论：使用数据复本

即：能不使用共享数据就不要使用共享数据，权衡共享和不共享两种方式的成本

![image-20211106140145532](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061401583.png)



##### 4.线程尽可能的独立

类似httpServlet ,每个请求有各自的线程处理，互不干扰，数据不共享

![image-20211106140350926](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061403006.png)



#### 四、java库

![image-20211106140801955](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061408044.png)



#### 五、了解执行模型

![image-20211106140825637](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061408698.png)

##### 1.生产者-消费者模型

![image-20211106140922478](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061409539.png)

两种类型线程： 一种生产，一种消费，消费线程只要判断有限定资源即可消费处理

##### 2、读者-作者模型

![image-20211106141119239](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061411308.png)

```
1).读者和读者之间，读者与读者之间是可以并发的访问某种资源的，所以他们之间是没有关系的。

2).读者和写者之间，我们知道对一个文件来说是不可以既读又写的，可能会导致数据的二义性问题。读者和写着之间是互斥和同步的关系。

3).写着和写着之间，存在互斥的关系。
```

它与生产者与消费者模型最大的区别在于：
<1>.生产者与消费者模型里，只存在互斥与同步，而在读者与写着模型里出现了读者与读者之间的共享关系。
<2>.它俩之间最大的区别就是生产者与消费者模型是会将临界区里的数据取走，而读者与写者模型只是将数据只读不取。

2.在上面描述读者写者关系中提到了互斥和同步，那么为什么要保证互斥和同步的关系呢？

```
互斥：指某一种资源某一时刻只能允许一个访问者对它进行访问，具有唯一性和排他性。但是资源的互斥是无法保证访问者对资源的访问顺序的，即如果有多个访问者访问该资源时，访问是无顺序的。

同步：同步是在互斥的基础上(大多数是互斥+同步，有的情况下只需要同步)，通过一些机制实现访问者对资源的有序访问。

理解了互斥和同步让我们继续来看读者和写者问题，我们知道读者在读的过程中存在查找操作，费时较长，如果给读者加锁会降低这种模型的实现效率，可以总结为读者写者模型就是一种多读少写的情况，为了解决这种情况，引入了读者锁的概念。
```

https://blog.csdn.net/qq_35032155/article/details/73612430

##### 3、哲学家就餐模型



#### 六、测试线程代码

![image-20211106145121057](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061451105.png)

![image-20211106145230418](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061452473.png)

![image-20211106145317150](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061453212.png)

![image-20211106145242582](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061452617.png)

![image-20211106145338020](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061453085.png)

![image-20211106145258872](https://raw.githubusercontent.com/codecodeabc/Note-len/main/img/202111061452929.png)